//=================================================================================
// Cell.cpp
// Author: Tyler George
// Date  : August 20, 2015
//=================================================================================


////===========================================================================================
///===========================================================================================
// Includes
///===========================================================================================
////===========================================================================================

#include "GameCode/Cell.hpp"
#include "GameCode/Entities/Entity.hpp"
#include "GameCode/Entities/Feature.hpp"
#include "GameCode/Inventory.hpp"

////===========================================================================================
///===========================================================================================
// Static Variable Initialization
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Constructors/Destructors
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Cell::Cell( CellType type, MapPosition mapPos, AABB2D renderBounds )
    : m_type( type )
    , m_mapPosition( mapPos )
    , m_renderBoundaries( renderBounds )
    , m_isActive( false )
    , m_isTrulyHidden( false )
    , m_isVisible( true )
    , m_isKnown( false )
    , m_entity( nullptr )
    , m_feature( nullptr )
    , m_inventory( nullptr )
{

}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
Cell::~Cell()
{

}


////===========================================================================================
///===========================================================================================
// Initialization
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Accessors/Queries
///===========================================================================================
////===========================================================================================


////===========================================================================================
///===========================================================================================
// Mutators
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Cell::SetVisible( bool isVisible )
{
    m_isVisible = isVisible;
    if (m_isVisible)
        m_isKnown = true;
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Cell::AddItem( Item* item, Map* map )
{
    if (!m_inventory)
        m_inventory = new Inventory( map, m_mapPosition );

    m_inventory->AddToBackpack( item, false );
}


////===========================================================================================
///===========================================================================================
// Update
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Cell::ProcessInput( InputSystem* inputSystem, double deltaSeconds )
{
    UNUSED( inputSystem );
    UNUSED( deltaSeconds );
}

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Cell::Update( double deltaSeconds, bool debugModeEnabled )
{
    UNUSED( debugModeEnabled );
    UNUSED( deltaSeconds );
}


////===========================================================================================
///===========================================================================================
// Render
///===========================================================================================
////===========================================================================================

///---------------------------------------------------------------------------------
///
///---------------------------------------------------------------------------------
void Cell::Render( OpenGLRenderer* renderer, FontRenderer* fontRenderer, const Font& font, const unsigned int& shaderID, bool debugModeEnabled )
{
	// #KSH: Since this gets called many times per frame, and the paradigm you have here is that each cell has a single glyph character,
	// consider returning const char*, and never duplicating (and allocating) a string.  If you must use strings, consider having them
	// preallocated and returning just a const reference.
    if (!renderer || !fontRenderer)
        return;

    if (m_isTrulyHidden || ( !m_isVisible && !m_isKnown ) )
        return;

    Vector3 position = Vector3( m_renderBoundaries.m_mins.x, m_renderBoundaries.m_mins.y, 4.0f );
    char symbol = ' ';

    switch (m_type)
    {
    case CT_INVALID:
        break;
    case CT_AIR:
        symbol = '.';
        break;
    case CT_WALL:
        symbol = '#';
        break;
    }

    Rgba alphaModifier; 
    if ( debugModeEnabled )
        alphaModifier = Rgba( 0.0f, 1.0f, 0.0f, 1.0f );

    if (!m_isVisible && m_isKnown)
    {
        alphaModifier = Rgba( 1.0f, 1.0f, 1.0f, 0.5f );

        if (debugModeEnabled)
            alphaModifier = Rgba( 1.0f, 0.0, 1.0f, 0.5f );
    }


         
    fontRenderer->DrawFontGlyphWH( m_renderBoundaries.m_maxs.x - m_renderBoundaries.m_mins.x, m_renderBoundaries.m_maxs.y - m_renderBoundaries.m_mins.y, font, symbol, position, alphaModifier );

    if (m_isActive)
        renderer->DrawColoredQuad( NULL, m_renderBoundaries.m_mins, m_renderBoundaries.m_maxs, 3.0f, Rgba::RED );

}

////===========================================================================================
///===========================================================================================
// Private Functions
///===========================================================================================
////===========================================================================================

